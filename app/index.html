<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Publication-ready GB Viewer</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 20px; background-color: #f4f6f9; color: #333; }
        .container { max-width: 1100px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1 { font-size: 1.5rem; border-bottom: 2px solid #0056b3; padding-bottom: 10px; margin-bottom: 20px; }
        
        .upload-section { padding: 30px; border: 2px dashed #0056b3; text-align: center; border-radius: 8px; background-color: #f1f8ff; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .upload-section:hover, .upload-section.dragover { background-color: #cce5ff; border-color: #004085; }
        .btn { background-color: #0056b3; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold; margin-top: 5px; }
        
        #info-box { margin-top: 15px; padding: 15px; border-radius: 4px; display: none; word-break: break-all; font-size: 1.1em; }
        .error { background-color: #ffe6e6; color: #d93025; border: 1px solid #f5c6c6;}
        .success { background-color: #e6f4ea; color: #1e8e3e; border: 1px solid #ceead6;}
        .loading { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba;}
        
        #controls { display: none; margin-top: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; }
        .controls-header { display: flex; gap: 30px; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .bw-toggle-label { font-weight: bold; cursor: pointer; color: #0056b3; background: #e2f0ff; padding: 6px 12px; border-radius: 6px; border: 1px solid #b8daff; }
        
        .filter-container { max-height: 250px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #fff; border-radius: 4px; display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px; }
        
        /* è¦ç´ ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ï¼ˆã‚«ãƒ©ãƒ¼é¸æŠUIï¼‰ */
        .filter-item { display: flex; flex-direction: column; gap: 5px; background: #f9f9f9; padding: 8px 12px; border-radius: 6px; border: 1px solid #eee; min-width: 220px; }
        .filter-item label { white-space: nowrap; cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.9em; margin: 0; font-weight: bold; color: #444; }
        .color-palette { display: flex; gap: 4px; align-items: center; }
        .color-swatch { width: 16px; height: 16px; border-radius: 3px; cursor: pointer; border: 1px solid #bbb; box-sizing: border-box; transition: transform 0.1s; }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.selected { border: 2px solid #0056b3; transform: scale(1.15); box-shadow: 0 0 3px rgba(0,86,179,0.5); }
        
        /* èƒŒæ™¯ã®è–„ã„æ¨ªç·šã¯éè¡¨ç¤º */
        #map-container { margin-top: 20px; overflow-x: auto; border: 1px solid #ddd; background-color: #fff; border-radius: 4px; }
        svg { display: block; }
        
        .draggable-label { cursor: move; user-select: none; }
        .draggable-label:hover { font-weight: bold; fill: #0056b3; }
        .draggable-feature { cursor: ns-resize; }
        .draggable-feature:hover { filter: brightness(0.9); }
        .draggable-scale { cursor: ns-resize; }
        .draggable-scale:hover line, .draggable-scale:hover text { opacity: 0.6; }
        .draggable-feature:active, .draggable-label:active, .draggable-scale:active { cursor: grabbing; }
        
        /* ç™½é»’è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ç”¨ */
        .bw-mode .feature-polygon { fill: #ffffff !important; stroke: #000000 !important; stroke-width: 2px !important; }
        .bw-mode .feature-polygon[data-is-primer="true"] { fill: #000000 !important; stroke: none !important; }
        
        .tooltip { position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 8px 12px; border-radius: 4px; font-size: 13px; pointer-events: none; display: none; z-index: 100; }
    </style>
</head>
<body>

<div class="container">
    <h1>DNA file (.gb) Viewer</h1>
    
    <label class="upload-section" id="drop-zone" for="fileInput">
        <span style="font-weight: bold; font-size: 1.1rem; color: #0056b3;">.gb ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</span>
        <span class="btn">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã¶</span>
        <span style="font-size: 0.9rem; color: #666;">ã¾ãŸã¯ã“ã“ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç›´æ¥ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</span>
        <input type="file" id="fileInput" accept=".gb,.genbank,.seq" style="display:none;">
    </label>

    <div id="info-box"></div>

    <div id="controls">
        <div class="controls-header">
            <div>
                <strong>æ–‡å­—ã‚µã‚¤ã‚º: </strong>
                <input type="range" id="fontSizeSlider" min="10" max="24" value="14">
                <span id="fontSizeDisplay">14px</span>
            </div>
            <div>
                <label class="bw-toggle-label">
                    <input type="checkbox" id="bwModeToggle"> ç™½é»’è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ï¼ˆè«–æ–‡ç”¨ï¼‰
                </label>
            </div>
            <div>
                <span style="font-size: 0.9em; color: #e65100; font-weight: bold;">
                    ğŸ’¡ å›³å½¢ã€æ–‡å­—ã€ã‚¹ã‚±ãƒ¼ãƒ«ãƒãƒ¼ã¯ãƒã‚¦ã‚¹ã§è‡ªç”±ã«ãƒ‰ãƒ©ãƒƒã‚°ã§ãã¾ã™
                </span>
            </div>
        </div>
        <div>
            <strong>è¡¨ç¤ºã¨è‰²ã®è¨­å®š (ãƒã‚§ãƒƒã‚¯ã‚’å¤–ã™ã¨éè¡¨ç¤º / å››è§’ã‚’ã‚¯ãƒªãƒƒã‚¯ã§è‰²å¤‰æ›´): </strong>
            <div id="filters"></div>
        </div>
    </div>

    <div id="map-container"></div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
    const infoBox = document.getElementById('info-box');
    function setStatus(type, msg) {
        infoBox.style.display = 'block';
        infoBox.className = type;
        infoBox.innerHTML = msg;
    }

    window.onerror = function(msg, url, lineNo) {
        setStatus('error', `<strong>ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼:</strong><br>${msg}<br>Line: ${lineNo}`);
        return false;
    };

    document.addEventListener("DOMContentLoaded", () => {
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('drop-zone');

        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                fileInput.files = e.dataTransfer.files;
                handleFile(fileInput.files[0]);
            }
        });

        // æœ€ã‚‚å®‰å®šã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å‡¦ç†
        fileInput.addEventListener('click', function() { this.value = ''; });
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) handleFile(file);
        });

        // ç™½é»’ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        const bwModeToggle = document.getElementById('bwModeToggle');
        bwModeToggle.addEventListener('change', (e) => {
            if (e.target.checked) document.body.classList.add('bw-mode');
            else document.body.classList.remove('bw-mode');
        });
    });

    function handleFile(file) {
        document.getElementById('controls').style.display = 'none';
        document.getElementById('map-container').innerHTML = '';
        setStatus('loading', 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§è§£æã—ã¦ã„ã¾ã™...');

        const reader = new FileReader();
        reader.onerror = () => { setStatus('error', 'ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); };

        reader.onload = function(e) {
            setTimeout(() => {
                try {
                    const text = e.target.result;
                    const parsedData = parseGenBankRobust(text);
                    
                    if (parsedData.length === 0) throw new Error("é…åˆ—ã®é•·ã•(LOCUS)ãŒç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
                    if (parsedData.length > 5000000) throw new Error("é…åˆ—ãŒé•·ã™ãã¾ã™ï¼ˆ500ä¸‡bpä»¥ä¸Šï¼‰ã€‚");
                    
                    setStatus('success', `<strong>è§£ææˆåŠŸ:</strong> å…¨é•· ${parsedData.length} bp / èªè­˜ã—ãŸç‰¹å¾´ ${parsedData.features.length} å€‹`);
                    setupControls(parsedData);
                    drawSequenceMap(parsedData);
                } catch (error) {
                    console.error(error);
                    setStatus('error', `<strong>ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:</strong><br>${error.message}`);
                }
            }, 50); 
        };
        reader.readAsText(file);
    }

    // å®‰å®šç‰ˆãƒ»é•·æ–‡æ³¨é‡ˆãƒ•ãƒªãƒ¼ã‚ºå¯¾ç­–æ¸ˆã¿ãƒ‘ãƒ¼ã‚µãƒ¼
    function parseGenBankRobust(text) {
        const lines = text.split(/\r\n|\n|\r/);
        let length = 0;
        let inFeatures = false;
        let currentFeature = null;
        let isParsingLocation = false;
        const features = [];
        
        // ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼8è‰² ï¼‹ ç™½é»’
        const pastelColors = ['#f8bbd0', '#bbdefb', '#c8e6c9', '#fff9c4', '#e1bee7', '#ffccbc', '#d7ccc8', '#b2dfdb'];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.startsWith('LOCUS')) {
                const bpMatch = line.match(/(\d+)\s*bp/i);
                if (bpMatch) length = parseInt(bpMatch[1], 10);
                else {
                    const parts = line.trim().split(/\s+/);
                    length = parseInt(parts[2], 10); 
                }
            } else if (line.startsWith('FEATURES')) {
                inFeatures = true;
            } else if (line.startsWith('ORIGIN') || line.startsWith('//')) {
                inFeatures = false;
                if (currentFeature) features.push(currentFeature);
                break;
            } else if (inFeatures) {
                if (line.length > 5 && line.charAt(4) === ' ' && line.charAt(5) !== ' ') {
                    if (currentFeature) features.push(currentFeature);
                    const parts = line.trim().split(/\s+/);
                    currentFeature = { type: parts[0], locStr: parts.slice(1).join(''), qualifiers: {} };
                    isParsingLocation = true; 
                } 
                else if (line.indexOf('/') !== -1 && line.trim().startsWith('/')) {
                    isParsingLocation = false; 
                    if (currentFeature) {
                        const qualStr = line.trim().substring(1);
                        const eqIdx = qualStr.indexOf('=');
                        if (eqIdx !== -1) {
                            const key = qualStr.substring(0, eqIdx);
                            const val = qualStr.substring(eqIdx + 1).replace(/(^"|"$)/g, '');
                            currentFeature.qualifiers[key] = val;
                        }
                    }
                } 
                else if (line.startsWith('      ') && currentFeature) {
                    if (isParsingLocation) currentFeature.locStr += line.trim(); 
                }
            }
        }

        const validFeatures = [];
        let colorIndex = 0;

        features.forEach((f, idx) => {
            if (f.type === 'source') return; 
            f.strand = f.locStr.includes('complement') ? -1 : 1;
            
            const nums = [...f.locStr.matchAll(/\b(\d+)\b/g)].map(m => parseInt(m[1], 10));
            if (nums.length === 0) return;
            
            f.start = Math.min(...nums);
            f.end = Math.max(...nums);
            if (isNaN(f.start) || isNaN(f.end)) return;

            f.name = f.qualifiers.label || f.qualifiers.ApEinfo_label || f.qualifiers.gene || f.qualifiers.name || f.qualifiers.note || f.type;
            if (f.name.startsWith('sequence:')) f.name = f.type;
            
            f.id = 'feat-id-' + idx;
            
            // åˆæœŸã®è‰²ã®å‰²ã‚Šå½“ã¦ï¼ˆãƒ—ãƒ©ã‚¤ãƒãƒ¼ã¯é»’ã€ãã‚Œä»¥å¤–ã¯é †ç•ªã«ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ï¼‰
            const isPrimer = f.type.toLowerCase().includes('primer');
            if (isPrimer) {
                f.defaultColor = '#000000';
            } else {
                f.defaultColor = pastelColors[colorIndex % pastelColors.length];
                colorIndex++;
            }

            validFeatures.push(f);
        });

        return { length, features: validFeatures };
    }

    // å››è§’å½¢(ã‚«ãƒ©ãƒ¼ã‚¹ã‚¦ã‚©ãƒƒãƒ)ã‚’ç”¨ã„ãŸUIã®æ§‹ç¯‰
    function setupControls(data) {
        document.getElementById('controls').style.display = 'block';
        const filtersDiv = document.getElementById('filters');
        filtersDiv.innerHTML = '<div class="filter-container" id="filter-container"></div>';
        const container = document.getElementById('filter-container');
        
        // ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼8è‰² ï¼‹ ç™½ ï¼‹ é»’
        const availableColors = ['#f8bbd0', '#bbdefb', '#c8e6c9', '#fff9c4', '#e1bee7', '#ffccbc', '#d7ccc8', '#b2dfdb', '#ffffff', '#000000'];

        data.features.forEach(feat => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'filter-item';
            
            const dispName = feat.name.length > 20 ? feat.name.substring(0, 18) + '...' : feat.name;
            
            // 1. ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨åå‰
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" class="elem-filter" value="${feat.id}" checked> ${dispName} <span style="color:#888; font-weight:normal;">(${feat.type})</span>`;
            
            // 2. ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆã®ç”Ÿæˆ
            const paletteDiv = document.createElement('div');
            paletteDiv.className = 'color-palette';
            
            availableColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                
                // åˆæœŸè‰²ã¨ä¸€è‡´ã—ã¦ã„ã‚Œã°é¸æŠçŠ¶æ…‹ã«ã™ã‚‹
                if (color === feat.defaultColor) {
                    swatch.classList.add('selected');
                }

                // è‰²ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†
                swatch.addEventListener('click', function() {
                    // ä»–ã®é¸æŠã‚’è§£é™¤
                    const siblings = paletteDiv.querySelectorAll('.color-swatch');
                    siblings.forEach(s => s.classList.remove('selected'));
                    // ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‚ã®ã‚’é¸æŠçŠ¶æ…‹ã«
                    this.classList.add('selected');
                    
                    // å¯¾å¿œã™ã‚‹å›³å½¢(ãƒãƒªã‚´ãƒ³)ã®è‰²ã‚’å³åº§ã«å¤‰æ›´
                    const poly = document.querySelector(`polygon[data-id="${feat.id}"]`);
                    if (poly) {
                        poly.setAttribute('fill', color);
                    }
                });
                paletteDiv.appendChild(swatch);
            });
            
            itemDiv.appendChild(label);
            itemDiv.appendChild(paletteDiv);
            container.appendChild(itemDiv);
        });

        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹è¡¨ç¤ºãƒ»éè¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
        document.querySelectorAll('.elem-filter').forEach(cb => {
            cb.addEventListener('change', (e) => {
                const id = e.target.value;
                const isChecked = e.target.checked;
                document.querySelectorAll(`[data-id="${id}"]`).forEach(el => {
                    el.style.display = isChecked ? 'block' : 'none';
                });
            });
        });

        // æ–‡å­—ã‚µã‚¤ã‚ºå¤‰æ›´
        const slider = document.getElementById('fontSizeSlider');
        const display = document.getElementById('fontSizeDisplay');
        slider.addEventListener('input', (e) => {
            const size = e.target.value;
            display.textContent = `${size}px`;
            document.querySelectorAll('.draggable-label').forEach(el => {
                el.setAttribute('font-size', `${size}px`);
            });
        });
    }

    // å¼•ãå‡ºã—ç·šã®ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶š
    function updateLineConnection(line, text) {
        const textX = parseFloat(text.getAttribute("x"));
        const textY = parseFloat(text.getAttribute("y"));
        const topY = parseFloat(line.getAttribute("data-current-y-top"));
        const bottomY = parseFloat(line.getAttribute("data-current-y-bottom"));
        const centerX = parseFloat(line.getAttribute("data-center-x"));
        const centerY = (topY + bottomY) / 2;

        line.setAttribute("x1", centerX); 
        line.setAttribute("x2", textX);   

        if (textY < centerY) {
            line.setAttribute("y1", topY);
            line.setAttribute("y2", textY + 4); 
        } else {
            line.setAttribute("y1", bottomY);
            line.setAttribute("y2", textY - 14); 
        }
    }

    function drawSequenceMap(data) {
        const container = document.getElementById('map-container');
        container.innerHTML = ''; 

        const svgWidth = 1050;
        const svgHeight = 650; 
        const margin = 50;
        const drawWidth = svgWidth - (margin * 2);
        
        const safeLength = data.length > 0 ? data.length : 1;
        const scale = drawWidth / safeLength;
        const baseY = 250; 

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        svg.setAttribute("id", "main-svg");

        // ãƒãƒƒã‚¯ãƒœãƒ¼ãƒ³
        const backbone = document.createElementNS("http://www.w3.org/2000/svg", "line");
        backbone.setAttribute("x1", margin - 20);
        backbone.setAttribute("y1", baseY);
        backbone.setAttribute("x2", margin + drawWidth + 20);
        backbone.setAttribute("y2", baseY);
        backbone.setAttribute("stroke", "#000");
        backbone.setAttribute("stroke-width", "3");
        svg.appendChild(backbone);

        // ã‚¹ã‚±ãƒ¼ãƒ«ãƒãƒ¼
        const scaleGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        scaleGroup.setAttribute("class", "draggable-scale");
        const scaleY = 500; 

        const hitbox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hitbox.setAttribute("x", margin - 20);
        hitbox.setAttribute("y", scaleY - 15);
        hitbox.setAttribute("width", drawWidth + 40);
        hitbox.setAttribute("height", 45);
        hitbox.setAttribute("fill", "transparent");
        scaleGroup.appendChild(hitbox);

        const scaleLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        scaleLine.setAttribute("x1", margin);
        scaleLine.setAttribute("y1", scaleY);
        scaleLine.setAttribute("x2", margin + drawWidth);
        scaleLine.setAttribute("y2", scaleY);
        scaleLine.setAttribute("stroke", "#000");
        scaleLine.setAttribute("stroke-width", "2");
        scaleGroup.appendChild(scaleLine);

        for (let i = 0; i <= safeLength; i += 1000) {
            const tickX = margin + (i * scale);
            const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
            tick.setAttribute("x1", tickX);
            tick.setAttribute("y1", scaleY - 6);
            tick.setAttribute("x2", tickX);
            tick.setAttribute("y2", scaleY + 6);
            tick.setAttribute("stroke", "#000");
            tick.setAttribute("stroke-width", "1.5");
            scaleGroup.appendChild(tick);

            const tickText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            tickText.setAttribute("x", tickX);
            tickText.setAttribute("y", scaleY + 22);
            tickText.setAttribute("text-anchor", "middle");
            tickText.setAttribute("font-size", "12px");
            tickText.setAttribute("fill", "#000");
            tickText.textContent = i === 0 ? "1" : i; 
            scaleGroup.appendChild(tickText);
        }

        if (safeLength % 1000 !== 0) {
            const endTickX = margin + drawWidth;
            const endTick = document.createElementNS("http://www.w3.org/2000/svg", "line");
            endTick.setAttribute("x1", endTickX);
            endTick.setAttribute("y1", scaleY - 6);
            endTick.setAttribute("x2", endTickX);
            endTick.setAttribute("y2", scaleY + 6);
            endTick.setAttribute("stroke", "#000");
            endTick.setAttribute("stroke-width", "1.5");
            scaleGroup.appendChild(endTick);

            const endTickText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            endTickText.setAttribute("x", endTickX);
            endTickText.setAttribute("y", scaleY + 22);
            endTickText.setAttribute("text-anchor", "middle");
            endTickText.setAttribute("font-size", "12px");
            endTickText.setAttribute("fill", "#000");
            endTickText.textContent = safeLength;
            scaleGroup.appendChild(endTickText);
        }
        svg.appendChild(scaleGroup);

        const tooltip = document.getElementById('tooltip');
        data.features.sort((a, b) => (b.end - b.start) - (a.end - a.start));

        data.features.forEach((feat, index) => {
            const featId = feat.id; 
            const x1 = margin + (feat.start * scale);
            const x2 = margin + (feat.end * scale);
            const width = Math.max(x2 - x1, 8); 
            const drawX1 = x1;
            const drawX2 = x1 + width;
            const centerX = drawX1 + (width / 2);
            
            const isPrimer = feat.type.toLowerCase().includes('primer');
            const yCenter = baseY; 
            const arrowHeight = isPrimer ? 16 : 28; 
            const yTop = yCenter - (arrowHeight / 2);
            const yBottom = yCenter + (arrowHeight / 2);

            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            let points = "";

            if (isPrimer) {
                const tipSize = Math.min(10, width);
                const shaftTop = yCenter - 4;
                const shaftBot = yCenter + 4;
                if (feat.strand === 1) { 
                    points = `${drawX1},${shaftTop} ${drawX2-tipSize},${shaftTop} ${drawX2-tipSize},${yTop} ${drawX2},${yCenter} ${drawX2-tipSize},${yBottom} ${drawX2-tipSize},${shaftBot} ${drawX1},${shaftBot}`;
                } else { 
                    points = `${drawX2},${shaftTop} ${drawX1+tipSize},${shaftTop} ${drawX1+tipSize},${yTop} ${drawX1},${yCenter} ${drawX1+tipSize},${yBottom} ${drawX1+tipSize},${shaftBot} ${drawX2},${shaftBot}`;
                }
            } else {
                const headSize = Math.min(15, width);
                if (feat.strand === 1) { 
                    points = `${drawX1},${yTop} ${drawX2-headSize},${yTop} ${drawX2},${yCenter} ${drawX2-headSize},${yBottom} ${drawX1},${yBottom}`;
                } else { 
                    points = `${drawX2},${yTop} ${drawX1+headSize},${yTop} ${drawX1},${yCenter} ${drawX1+headSize},${yBottom} ${drawX2},${yBottom}`;
                }
            }

            poly.setAttribute("points", points);
            poly.setAttribute("data-id", featId); 
            poly.setAttribute("data-text-id", `text-${featId}`);
            poly.setAttribute("data-is-primer", isPrimer ? "true" : "false");
            
            // è‰²ã¯ãƒ‘ãƒ¼ã‚¹æ™‚ã«æ±ºã‚ãŸ defaultColor
            poly.setAttribute("fill", feat.defaultColor);
            poly.setAttribute("stroke", isPrimer ? "none" : "#000");
            poly.setAttribute("stroke-width", isPrimer ? "0" : "2");
            poly.setAttribute("class", "draggable-feature feature-polygon");
            const lineId = `line-${featId}`;
            poly.setAttribute("data-line", lineId);
            svg.appendChild(poly);

            // å¼•ãå‡ºã—ç·š
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("id", lineId);
            line.setAttribute("data-id", featId);
            line.setAttribute("stroke", "#666");
            line.setAttribute("stroke-width", "1.5");
            line.setAttribute("stroke-dasharray", "4,4"); 
            line.setAttribute("data-center-x", centerX);
            line.setAttribute("data-orig-y-top", yTop);
            line.setAttribute("data-orig-y-bottom", yBottom);
            line.setAttribute("data-current-y-top", yTop);
            line.setAttribute("data-current-y-bottom", yBottom);
            svg.appendChild(line);

            // ãƒ†ã‚­ã‚¹ãƒˆ
            const textYOffset = isPrimer ? 60 + (index % 2)*20 : -60 - (index % 3)*20;
            const initialTextY = baseY + textYOffset;

            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("id", `text-${featId}`);
            text.setAttribute("data-id", featId);
            text.setAttribute("x", centerX);
            text.setAttribute("y", initialTextY);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "14px");
            text.setAttribute("fill", "#000");
            text.setAttribute("class", "draggable-label");
            text.setAttribute("data-line", lineId);
            text.textContent = feat.name.length > 25 ? feat.name.substring(0, 23) + '...' : feat.name;
            svg.appendChild(text);

            updateLineConnection(line, text);

            poly.addEventListener('mousemove', (e) => {
                tooltip.style.display = 'block';
                tooltip.style.left = e.pageX + 15 + 'px';
                tooltip.style.top = e.pageY + 15 + 'px';
                tooltip.innerHTML = `<strong>${feat.name}</strong><br><span style="color:#ddd">${feat.type}</span><br>${feat.start} - ${feat.end} bp`;
            });
            poly.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
        });

        container.appendChild(svg);
        enableInteractions(svg);
    }

    function enableInteractions(svg) {
        let draggedText = null;
        let draggedFeature = null;
        let draggedScale = null;
        let dragOffset = { x: 0, y: 0 };
        let initialTranslateY = 0;
        const TRACK_HEIGHT = 40; 

        function getMousePos(e) {
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }

        svg.addEventListener('mousedown', (e) => {
            let target = e.target;
            
            let scaleTarget = target;
            while (scaleTarget !== svg && scaleTarget) {
                if (scaleTarget.classList && scaleTarget.classList.contains('draggable-scale')) {
                    draggedScale = scaleTarget;
                    const pt = getMousePos(e);
                    dragOffset.y = pt.y; 
                    if (draggedScale.transform.baseVal.numberOfItems === 0) {
                        const translate = svg.createSVGTransform();
                        translate.setTranslate(0, 0);
                        draggedScale.transform.baseVal.insertItemBefore(translate, 0);
                    }
                    initialTranslateY = draggedScale.transform.baseVal.getItem(0).matrix.f;
                    return; 
                }
                scaleTarget = scaleTarget.parentNode;
            }

            if (target.classList.contains('draggable-label')) {
                draggedText = target;
                const pt = getMousePos(e);
                dragOffset.x = pt.x - parseFloat(draggedText.getAttribute('x'));
                dragOffset.y = pt.y - parseFloat(draggedText.getAttribute('y'));
                draggedText.parentNode.appendChild(draggedText);
            } 
            else if (target.classList.contains('draggable-feature')) {
                draggedFeature = target;
                const pt = getMousePos(e);
                dragOffset.y = pt.y; 
                if (draggedFeature.transform.baseVal.numberOfItems === 0) {
                    const translate = svg.createSVGTransform();
                    translate.setTranslate(0, 0);
                    draggedFeature.transform.baseVal.insertItemBefore(translate, 0);
                }
                initialTranslateY = draggedFeature.transform.baseVal.getItem(0).matrix.f;
            }
        });

        svg.addEventListener('mousemove', (e) => {
            if (draggedText) {
                e.preventDefault();
                const pt = getMousePos(e);
                const newX = pt.x - dragOffset.x;
                const newY = pt.y - dragOffset.y;
                draggedText.setAttribute('x', newX);
                draggedText.setAttribute('y', newY);
                
                const lineId = draggedText.getAttribute('data-line');
                const line = document.getElementById(lineId);
                if (line) updateLineConnection(line, draggedText);
            } 
            else if (draggedFeature) {
                e.preventDefault();
                const pt = getMousePos(e);
                const deltaY = pt.y - dragOffset.y;
                const snappedY = Math.round((initialTranslateY + deltaY) / TRACK_HEIGHT) * TRACK_HEIGHT;
                draggedFeature.transform.baseVal.getItem(0).setTranslate(0, snappedY);
                
                const lineId = draggedFeature.getAttribute('data-line');
                const line = document.getElementById(lineId);
                const textId = draggedFeature.getAttribute('data-text-id');
                const text = document.getElementById(textId);
                
                if (line && text) {
                    const origTop = parseFloat(line.getAttribute('data-orig-y-top'));
                    const origBottom = parseFloat(line.getAttribute('data-orig-y-bottom'));
                    line.setAttribute('data-current-y-top', origTop + snappedY);
                    line.setAttribute('data-current-y-bottom', origBottom + snappedY);
                    updateLineConnection(line, text);
                }
            }
            else if (draggedScale) {
                e.preventDefault();
                const pt = getMousePos(e);
                const deltaY = pt.y - dragOffset.y;
                const newY = initialTranslateY + deltaY;
                draggedScale.transform.baseVal.getItem(0).setTranslate(0, newY);
            }
        });

        const endDrag = () => { draggedText = null; draggedFeature = null; draggedScale = null; };
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
    }
</script>

</body>
</html>
